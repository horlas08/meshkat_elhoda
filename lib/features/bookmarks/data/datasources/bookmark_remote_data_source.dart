import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../models/bookmark_model.dart';

abstract class BookmarkRemoteDataSource {
  Future<void> addBookmark({
    required int surahNumber,
    required String surahName,
    required int ayahNumber,
    required String ayahText,
    String? note,
  });

  Future<List<BookmarkModel>> getBookmarks();
  Future<void> deleteBookmark(String bookmarkId);
  Future<bool> isBookmarked({
    required int surahNumber,
    required int ayahNumber,
  });
  Future<String?> getBookmarkId({
    required int surahNumber,
    required int ayahNumber,
  });
}

class BookmarkRemoteDataSourceImpl implements BookmarkRemoteDataSource {
  final FirebaseFirestore firestore;
  final FirebaseAuth auth;

  BookmarkRemoteDataSourceImpl({
    required this.firestore,
    required this.auth,
  });

  String get _userId {
    final user = auth.currentUser;
    if (user == null) {
      throw Exception('User not authenticated');
    }
    return user.uid;
  }

  CollectionReference get _bookmarksCollection {
    return firestore.collection('users').doc(_userId).collection('bookmarks');
  }

  @override
  Future<void> addBookmark({
    required int surahNumber,
    required String surahName,
    required int ayahNumber,
    required String ayahText,
    String? note,
  }) async {
    try {
      final bookmark = BookmarkModel(
        id: '', // Will be generated by Firestore
        surahNumber: surahNumber,
        surahName: surahName,
        ayahNumber: ayahNumber,
        ayahText: ayahText,
        createdAt: DateTime.now(),
        note: note,
      );

      await _bookmarksCollection.add(bookmark.toFirestore());
    } catch (e) {
      throw Exception('Failed to add bookmark: $e');
    }
  }

  @override
  Future<List<BookmarkModel>> getBookmarks() async {
    try {
      final querySnapshot = await _bookmarksCollection
          .orderBy('createdAt', descending: true)
          .get();

      return querySnapshot.docs
          .map((doc) => BookmarkModel.fromFirestore(doc))
          .toList();
    } catch (e) {
      throw Exception('Failed to fetch bookmarks: $e');
    }
  }

  @override
  Future<void> deleteBookmark(String bookmarkId) async {
    try {
      await _bookmarksCollection.doc(bookmarkId).delete();
    } catch (e) {
      throw Exception('Failed to delete bookmark: $e');
    }
  }

  @override
  Future<bool> isBookmarked({
    required int surahNumber,
    required int ayahNumber,
  }) async {
    try {
      final querySnapshot = await _bookmarksCollection
          .where('surahNumber', isEqualTo: surahNumber)
          .where('ayahNumber', isEqualTo: ayahNumber)
          .limit(1)
          .get();

      return querySnapshot.docs.isNotEmpty;
    } catch (e) {
      throw Exception('Failed to check bookmark status: $e');
    }
  }

  @override
  Future<String?> getBookmarkId({
    required int surahNumber,
    required int ayahNumber,
  }) async {
    try {
      final querySnapshot = await _bookmarksCollection
          .where('surahNumber', isEqualTo: surahNumber)
          .where('ayahNumber', isEqualTo: ayahNumber)
          .limit(1)
          .get();

      if (querySnapshot.docs.isEmpty) {
        return null;
      }

      return querySnapshot.docs.first.id;
    } catch (e) {
      throw Exception('Failed to get bookmark ID: $e');
    }
  }
}
